import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/firebase-admin";
import { getUserFromToken } from "@/lib/auth";
import { v4 as uuidv4 } from "uuid";

interface NewsVideoRequest {
  title: string;
  description?: string;
  prompts: string[];
  narrations: string[];
  scenes: Array<{
    scene_number: number;
    image_prompt: string;
    narration: string;
    imageUrl?: string;
  }>;
  model: string;
  aspectRatio: string;
  duration: number;
  veo3Resolution?: "720p" | "1080p";
  videoId?: string; // Í∏∞Ï°¥ ÎπÑÎîîÏò§ ID (Add Scenes Ïãú)
  isAddScene?: boolean; // Add Scenes ÌîåÎûòÍ∑∏
}

export async function POST(request: NextRequest) {
  try {
    // Ïù∏Ï¶ù ÌôïÏù∏
    const user = await getUserFromToken();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const uid = user.uid;
    const body: NewsVideoRequest = await request.json();

    console.log("API Request Body:", JSON.stringify(body, null, 2));
    const {
      title,
      description,
      prompts,
      narrations,
      scenes,
      model,
      aspectRatio,
      duration,
      veo3Resolution,
      videoId: existingVideoId,
      isAddScene,
    } = body;

    // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (isAddScene && existingVideoId) {
      // Add Scenes Ïãú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
      if (!scenes || scenes.length === 0) {
        return NextResponse.json(
          { error: "At least one scene is required" },
          { status: 400 }
        );
      }

      const scene = scenes[0];
      if (!scene.image_prompt?.trim()) {
        return NextResponse.json(
          { error: "Image prompt is required" },
          { status: 400 }
        );
      }

      if (!scene.narration?.trim()) {
        return NextResponse.json(
          { error: "Narration is required" },
          { status: 400 }
        );
      }
    } else {
      // ÏÉàÎ°úÏö¥ ÎπÑÎîîÏò§ ÏÉùÏÑ± Ïãú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
      if (!title?.trim()) {
        return NextResponse.json(
          { error: "Title is required" },
          { status: 400 }
        );
      }

      if (!prompts || prompts.length === 0) {
        return NextResponse.json(
          { error: "At least one prompt is required" },
          { status: 400 }
        );
      }
    }

    const now = new Date();
    const videoId = existingVideoId || uuidv4();

    // ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏
    if (!process.env.REPLICATE_API_TOKEN) {
      console.error("REPLICATE_API_TOKEN not configured");
      return NextResponse.json(
        { error: "Replicate API token not configured" },
        { status: 500 }
      );
    }

    if (isAddScene && existingVideoId) {
      // Í∏∞Ï°¥ ÎπÑÎîîÏò§Ïóê Add Scenes
      const existingVideoRef = db
        .collection("users")
        .doc(uid)
        .collection("newsVideo")
        .doc(existingVideoId);
      const existingVideoDoc = await existingVideoRef.get();

      if (!existingVideoDoc.exists) {
        return NextResponse.json({ error: "Video not found" }, { status: 404 });
      }

      const existingVideoData = existingVideoDoc.data();
      if (!existingVideoData) {
        return NextResponse.json(
          { error: "Video data not found" },
          { status: 404 }
        );
      }
      const currentScenes = existingVideoData.scenes || [];
      const newSceneNumber = currentScenes.length + 1;

      // ÏÉà Add Scenes
      const newScene = {
        ...scenes[0], // Ï≤´ Î≤àÏß∏ SceneÎßå ÏÇ¨Ïö©
        scene_number: newSceneNumber,
        videoUrl: "", // ÎπÑÎîîÏò§ ÏÉùÏÑ± ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
      };

      const updatedScenes = [...currentScenes, newScene];

      // Í∏∞Ï°¥ ÎπÑÎîîÏò§ ÏóÖÎç∞Ïù¥Ìä∏
      await existingVideoRef.update({
        scenes: updatedScenes,
        updatedAt: now,
      });

      // ÏÉà SceneÏóê ÎåÄÌï¥ÏÑúÎßå ÎπÑÎîîÏò§ ÏÉùÏÑ±
      const sceneVideoId = uuidv4();
      const scene = scenes[0];

      // Î™®Îç∏Ïóê Îî∞Î•∏ API Ìò∏Ï∂ú
      let replicateResponse;
      if (model === "veo-3") {
        // Veo-3 API Ìò∏Ï∂ú
        replicateResponse = await fetch(
          "https://api.replicate.com/v1/predictions",
          {
            method: "POST",
            headers: {
              Authorization: `Token ${process.env.REPLICATE_API_TOKEN}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              version: "google/veo-3",
              input: {
                prompt: scene.image_prompt,
                resolution: veo3Resolution || "720p",
                negative_prompt: "blurry, low quality, distorted",
              },
            }),
          }
        );
      } else {
        // Kling v2 API Ìò∏Ï∂ú (Í∏∞Î≥∏Í∞í)
        replicateResponse = await fetch(
          "https://api.replicate.com/v1/predictions",
          {
            method: "POST",
            headers: {
              Authorization: `Token ${process.env.REPLICATE_API_TOKEN}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              version: "kwaivgi/kling-v2.0",
              input: {
                prompt: scene.image_prompt,
                duration: existingVideoData.duration || 5,
                aspect_ratio: existingVideoData.aspectRatio || "16:9",
                cfg_scale: 0.5,
                negative_prompt: "blurry, low quality, distorted",
                ...(scene.imageUrl && { start_image: scene.imageUrl }),
              },
            }),
          }
        );
      }

      if (!replicateResponse.ok) {
        const errorText = await replicateResponse.text();
        console.error("Replicate API Error:", {
          status: replicateResponse.status,
          statusText: replicateResponse.statusText,
          error: errorText,
        });
        throw new Error(
          `Replicate API error: ${replicateResponse.status} - ${errorText}`
        );
      }

      const replicateData = await replicateResponse.json();
      console.log("Replicate API Response:", replicateData);

      // Scene ÎπÑÎîîÏò§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
      const sceneVideoData = {
        id: sceneVideoId,
        sceneIndex: currentScenes.length, // ÏÉà SceneÏùò Ïù∏Îç±Ïä§
        status: "starting" as const,
        prompt: scene.image_prompt,
        narration: scene.narration,
        replicatePredictionId: replicateData.id,
        created_at: now,
        updated_at: now,
      };

      // FirestoreÏóê Scene ÎπÑÎîîÏò§ Save
      await db
        .collection("users")
        .doc(uid)
        .collection("newsVideo")
        .doc(existingVideoId)
        .collection("sceneVideos")
        .doc(sceneVideoId)
        .set(sceneVideoData);

      return NextResponse.json({
        videoId: existingVideoId,
        sceneVideos: [sceneVideoData],
        message: "Scene added successfully",
      });
    } else {
      // ÏÉàÎ°úÏö¥ Generated Video ÏÉùÏÑ±
      const newsVideoData = {
        id: videoId,
        uid,
        title: title.trim(),
        description: description?.trim() || "",
        status: "processing" as const,
        prompts,
        narrations,
        scenes: scenes.map((scene, index) => ({
          ...scene,
          videoUrl: "", // ÎπÑÎîîÏò§ ÏÉùÏÑ± ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
        })),
        model,
        aspectRatio,
        duration,
        createdAt: now,
        updatedAt: now,
      };

      // FirestoreÏóê Save
      try {
        console.log("üíæ FirestoreÏóê ÎπÑÎîîÏò§ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏãúÏûë...");
        await db
          .collection("users")
          .doc(uid)
          .collection("newsVideo")
          .doc(videoId)
          .set(newsVideoData);
        console.log("‚úÖ FirestoreÏóê ÎπÑÎîîÏò§ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å");
      } catch (firestoreError) {
        console.error("‚ùå Firestore Ï†ÄÏû• Ïã§Ìå®:", firestoreError);
        const errorMessage =
          firestoreError instanceof Error
            ? firestoreError.message
            : String(firestoreError);
        throw new Error(`Firestore save failed: ${errorMessage}`);
      }

      // Í∞Å SceneÏóê ÎåÄÌï¥ ÎπÑÎîîÏò§ ÏÉùÏÑ±
      const videoPromises = scenes.map(async (scene, index) => {
        const sceneVideoId = uuidv4();

        // Î™®Îç∏Ïóê Îî∞Î•∏ API Ìò∏Ï∂ú
        let replicateResponse;
        if (model === "veo-3") {
          // Veo-3 API Ìò∏Ï∂ú
          replicateResponse = await fetch(
            "https://api.replicate.com/v1/predictions",
            {
              method: "POST",
              headers: {
                Authorization: `Token ${process.env.REPLICATE_API_TOKEN}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                version: "google/veo-3",
                input: {
                  prompt: prompts[index],
                  resolution: veo3Resolution || "720p",
                  negative_prompt: "blurry, low quality, distorted",
                },
              }),
            }
          );
        } else {
          // Kling v2 API Ìò∏Ï∂ú (Í∏∞Î≥∏Í∞í)
          replicateResponse = await fetch(
            "https://api.replicate.com/v1/predictions",
            {
              method: "POST",
              headers: {
                Authorization: `Token ${process.env.REPLICATE_API_TOKEN}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                version: "kwaivgi/kling-v2.0",
                input: {
                  prompt: prompts[index],
                  duration: duration,
                  aspect_ratio: aspectRatio,
                  cfg_scale: 0.5,
                  negative_prompt: "blurry, low quality, distorted",
                  ...(scene.imageUrl && { start_image: scene.imageUrl }),
                },
              }),
            }
          );
        }

        if (!replicateResponse.ok) {
          throw new Error(
            `Replicate API error: ${replicateResponse.statusText}`
          );
        }

        const replicateData = await replicateResponse.json();

        // Scene ÎπÑÎîîÏò§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        const sceneVideoData = {
          id: sceneVideoId,
          sceneIndex: index,
          status: "starting" as const,
          prompt: prompts[index],
          narration: narrations[index],
          replicatePredictionId: replicateData.id,
          created_at: now,
          updated_at: now,
        };

        // FirestoreÏóê Scene ÎπÑÎîîÏò§ Save
        await db
          .collection("users")
          .doc(uid)
          .collection("newsVideo")
          .doc(videoId)
          .collection("sceneVideos")
          .doc(sceneVideoId)
          .set(sceneVideoData);

        return sceneVideoData;
      });

      const sceneVideos = await Promise.all(videoPromises);

      return NextResponse.json({
        videoId,
        sceneVideos,
        message: `Started generating ${sceneVideos.length} scene videos`,
      });
    }
  } catch (error) {
    console.error("‚ùå ÎπÑÎîîÏò§ ÏÉùÏÑ± ÏóêÎü¨:", error);

    // ÏóêÎü¨ ÌÉÄÏûÖÎ≥Ñ ÏÉÅÏÑ∏ Î°úÍπÖ
    if (error instanceof Error) {
      console.error("ÏóêÎü¨ Î©îÏãúÏßÄ:", error.message);
      console.error("ÏóêÎü¨ Ïä§ÌÉù:", error.stack);
    }

    // ÏÇ¨Ïö©ÏûêÏóêÍ≤å Î∞òÌôòÌï† ÏóêÎü¨ Î©îÏãúÏßÄ
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error occurred";

    return NextResponse.json(
      {
        error: "Failed to generate news video",
        details: errorMessage,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    );
  }
}
